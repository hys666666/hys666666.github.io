<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeSong blog</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hys666666.github.io/"/>
  <updated>2019-08-18T03:07:14.389Z</updated>
  <id>http://hys666666.github.io/</id>
  
  <author>
    <name>CodeSong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二篇</title>
    <link href="http://hys666666.github.io/posts/43748377.html"/>
    <id>http://hys666666.github.io/posts/43748377.html</id>
    <published>2019-08-16T01:59:38.000Z</published>
    <updated>2019-08-18T03:07:14.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二篇博客，啦啦啦"><a href="#第二篇博客，啦啦啦" class="headerlink" title="第二篇博客，啦啦啦"></a>第二篇博客，啦啦啦</h1><h2 id="啦啦啦啦"><a href="#啦啦啦啦" class="headerlink" title="啦啦啦啦"></a>啦啦啦啦</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二篇博客，啦啦啦&quot;&gt;&lt;a href=&quot;#第二篇博客，啦啦啦&quot; class=&quot;headerlink&quot; title=&quot;第二篇博客，啦啦啦&quot;&gt;&lt;/a&gt;第二篇博客，啦啦啦&lt;/h1&gt;&lt;h2 id=&quot;啦啦啦啦&quot;&gt;&lt;a href=&quot;#啦啦啦啦&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="日常" scheme="http://hys666666.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="划水" scheme="http://hys666666.github.io/tags/%E5%88%92%E6%B0%B4/"/>
    
      <category term="吹牛逼" scheme="http://hys666666.github.io/tags/%E5%90%B9%E7%89%9B%E9%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>所谓的第一篇博客</title>
    <link href="http://hys666666.github.io/posts/undefined.html"/>
    <id>http://hys666666.github.io/posts/undefined.html</id>
    <published>2019-08-15T06:02:15.000Z</published>
    <updated>2019-08-15T12:32:22.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一二三四"><a href="#一二三四" class="headerlink" title="一二三四"></a>一二三四</h1><h5 id="1234"><a href="#1234" class="headerlink" title="1234"></a>1234</h5><h2 id="321"><a href="#321" class="headerlink" title="321"></a>321</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一二三四&quot;&gt;&lt;a href=&quot;#一二三四&quot; class=&quot;headerlink&quot; title=&quot;一二三四&quot;&gt;&lt;/a&gt;一二三四&lt;/h1&gt;&lt;h5 id=&quot;1234&quot;&gt;&lt;a href=&quot;#1234&quot; class=&quot;headerlink&quot; title=&quot;1234&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="frist" scheme="http://hys666666.github.io/tags/frist/"/>
    
  </entry>
  
  <entry>
    <title>C#复习知识点提炼</title>
    <link href="http://hys666666.github.io/posts/2b58aa48.html"/>
    <id>http://hys666666.github.io/posts/2b58aa48.html</id>
    <published>2019-04-29T13:53:00.000Z</published>
    <updated>2019-08-22T11:56:38.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-知识点提炼期末复习专用"><a href="#C-知识点提炼期末复习专用" class="headerlink" title="C#知识点提炼期末复习专用"></a>C#知识点提炼期末复习专用</h1><hr><p>根据内部消息称，有三类题型：<br>程序阅读题：2题<br>简答题：2题 （主要是对概念的考查）<br>编程题：暂定2-3题  </p><p>复习要点：<br><strong>.net framework</strong><br>通用语言开发环境、.NET基础类库、.NET开发语言、visual studio.NET 集成开发环境</p><hr><h2 id="C-的特点"><a href="#C-的特点" class="headerlink" title="C#的特点"></a>C#的特点</h2><ol><li><p>语法简介</p></li><li><p>彻底的面向对象</p></li><li><p>与Web应用紧密结合</p></li><li><p>强大的安全机制</p></li><li><p>完善的错误、异常处理机制</p></li><li><p>灵活的版本处理技术</p></li><li><p>兼容性</p></li><li><p>（老师加的）全方位的跨平台支持</p></li></ol><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><ol><li>跨平台 </li><li>开源</li></ol><h2 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h2><p>值类型：<strong>该类型的数据长度固定，存放于栈内</strong></p><p>引用类型：<strong>该类型的数据长度可变，存放于堆内</strong></p><h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><ol><li><p>abstract 抽象类，不能创建该类的实例，只能作为基类</p></li><li><p>internal 老师说，在同一程序内部访问而非指某一个命名空间内部，其它命名空间用using来使用</p></li><li><p>new 用于声明嵌套的类</p></li><li><p>private 用于声明私有嵌套类，只能在定义它的类中访问这个类</p></li><li><p>protected 用于声明保护型嵌套类，只能在定义它的类以及该类的子类中访问这个类</p></li><li><p>public 该类可以被任何其它类访问</p></li><li><p>sealed 该类不能被继承</p></li></ol><h2 id="类成员修饰符有四类"><a href="#类成员修饰符有四类" class="headerlink" title="类成员修饰符有四类"></a>类成员修饰符有四类</h2><ol><li><p>public 公有成员</p></li><li><p>Private 私有成员</p></li><li><p>Protected 保护成员</p></li><li><p>Internal 内部成员</p></li></ol><h1 id="构造函数、析构函数"><a href="#构造函数、析构函数" class="headerlink" title="构造函数、析构函数"></a>构造函数、析构函数</h1><p>&emsp;&emsp;构造函数与类名相同，开头public，无返回值，主要对类的实例初始化，实例类时自动执行</p><p>&emsp;&emsp;析构函数名比析构函数多加了一个符号 ’~’，与构造函数区别在于，该函数在对象销毁时执行</p><h1 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h1><p><strong>继承</strong>本质是代码重用（具体懒得写）</p><p><strong>多态</strong>就是将子类赋值给父类，可以在父类中通过调用抽象方法来实现子类的具体功能</p><p><strong>ASP.NET,page</strong>实例的生命周期自己找去</p><h1 id="方法的重载与区分"><a href="#方法的重载与区分" class="headerlink" title="方法的重载与区分"></a>方法的重载与区分</h1><p>&emsp;&emsp;重载指的是允许存在多个同名参数，而这些函数的参数呢，是不一样的，可以是类型不一样可以是个数不一样，然后再调用这个方法时，编译器可以按照输入的参数去调用适当的方法</p><h2 id="装箱和拆箱。重载。"><a href="#装箱和拆箱。重载。" class="headerlink" title="装箱和拆箱。重载。"></a>装箱和拆箱。重载。</h2><p>说简单点就是：把一个具体的子类对象赋值给了父类对象就可以理解为发生了装箱操作，将父类对象强转为具体的子类对象就是拆箱操作</p><p>里式转换法则：父类中包含的是子类对象，则可以强转成文子类对象</p><p>秀操作专用知识点</p><h1 id="c-面向对象的思想。"><a href="#c-面向对象的思想。" class="headerlink" title="c#面向对象的思想。"></a>c#面向对象的思想。</h1><p>面向对象的思想很简单，就是对象咯（似乎是废话）</p><p>面向对象是一种模块化的、以对象为基础的设计思想，现在被广泛应用于软件设计领域。</p><p>基本单元就是<strong>对象！对象！对象！</strong></p><p><strong>对象</strong>就是封装起来的代码块，功能模块？应该是的</p><p>本篇文章就是它的思想吧，太扯了跳过。。。</p><p>关键字 <strong>class</strong> 的使用和概念<br>定义类时需要用到的关键字</p><p>类是引用类型，在堆上分配地址</p><p>关键字<strong>struct</strong>的使用和概念<br>定义结构体是需要用到的关键字</p><p>结构体是值类型，在堆栈上分配地址（据网上所说堆栈就是栈，只是换了个抽象的名字，没具体了解）</p><h1 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h1><p>抽象方法：只包含了方法定义，但没有具体实现的方法，需要其子类或者子类的子类来具体实现。</p><p>抽象类：含有一个或多个抽象方法的类称为抽象类。抽象类不能被实例化，这是因为它包含了没有具体实现的方法。</p><ol><li>使用abstract关键字来定义抽象类和方法，使用格式如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SB</span> //定义了抽象类<span class="title">SB</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">DSB</span><span class="params">()</span></span>; <span class="comment">//定义了抽象方法DSB</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>子类继承抽象父类后，可以使用override关键字覆盖父类中的抽象方法，并做具体的实现，格式如下：</li></ol><p><strong>。。。。没有格式，把上面的abstract换成override就ojbk了</strong></p><h1 id="接口和类"><a href="#接口和类" class="headerlink" title="接口和类"></a>接口和类</h1><p>就是定义一组数据结构，通过这组数据结构可以调用组件对象的功能。反正和抽象类差不多，可以看成是类的模板</p><p>接口的特点、定义和使用<br>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SB</span>//关键字<span class="title">interface</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">DSB</span><span class="params">()</span></span>;<span class="comment">//接口已规定是public，声明时不需要访问级别修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以继承多个接口，实现接口中的方法不需要使用关键字“override”</p><p><strong>接口也可以实现多态，这和抽象类一样</strong>，书上一句很无语的话。。。</p><p>使用的时候就是子类继承啦。。。</p><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别?"></a>抽象类和接口的区别?</h1><ol><li><p>抽象类除了拥有抽象成员以外，还可以拥有非抽象成员；而接口所有成员都是抽象的；</p></li><li><p>抽象成员可以是私有的，而接口一般都是公开的（不太清楚这里的“一般”，那么“不一般”又是什么呢？）；</p></li><li><p>接口中不能含有构造函数、析构函数、静态成员、和常量；</p></li><li><p>C#只支持单继承，一个子类只能继承一个父类。而一个子类却能继承多个接口</p></li></ol><h1 id="Using-关键字两种用法"><a href="#Using-关键字两种用法" class="headerlink" title="Using 关键字两种用法"></a>Using 关键字两种用法</h1><p>一种是引用命名空间，另一种是。。。老师课堂上的忘了，但网上查了，如下：</p><p>定义一个范围，在范围结束时处理对象。</p><p>场景：</p><p>当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要离开了这个代码段就自动调用这个类实例的<strong>Dispose</strong>。</p><p>要达到这样的目的，用<strong>try…catch</strong>来捕捉异常也是可以的，但用<strong>using</strong>也很方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using (Class1 cls1 = <span class="keyword">new</span> Class1(), cls2 = <span class="keyword">new</span> Class1())</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the code using cls1, cls2</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// call the Dispose on cls1 and cls2</span></span><br></pre></td></tr></table></figure><p>网上说还有一种功能给命名空间起个“外号”。。。</p><h1 id="关键字new"><a href="#关键字new" class="headerlink" title="关键字new"></a>关键字new</h1><p>&emsp;&emsp;C#不允许在安全代码中使用指针，因此要处理对中的数据就需要使用引用类型，使用new关键字实例化引用数据类型的对象，并指向堆中的对象数据。</p><p>内置的引用类型有两种分别是System.Object和System.String</p><p>&emsp;&emsp;C#中数组也被看作一个带有方法和属性的对象，所以定义数组时，也需要用到new</p><h1 id="多态的特性及意义！"><a href="#多态的特性及意义！" class="headerlink" title="多态的特性及意义！"></a>多态的特性及意义！</h1><p>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。</p><p>对不同类的对象发出相同的消息将会有不同的行为，就是同一个处理手段可以用来处理多种不同的情况</p><p>没有继承就没有多态！</p><ol><li><p>提高了代码的维护性(继承保证)</p></li><li><p>提高了代码的扩展性(由多态保证)</p></li></ol><p>全是网上查的，这算是特性和意义吧。。。</p><h1 id="Namespace关键字"><a href="#Namespace关键字" class="headerlink" title="Namespace关键字"></a>Namespace关键字</h1><p>&emsp;&emsp;简单的说就是定义命名空间用的关键字，往复杂了说呢，说了也不懂，跳过</p><h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>流是.NET操作文件的基本类。对文件的输入输出操作都要用到流。流分为输入流和输出流。</p><p>懒得写了，课本165页。。。</p><p><strong><em>书本重点例题：p32   p82p83  p89-91  p97 p99 p117  p113（改写后的代码） p175</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-知识点提炼期末复习专用&quot;&gt;&lt;a href=&quot;#C-知识点提炼期末复习专用&quot; class=&quot;headerlink&quot; title=&quot;C#知识点提炼期末复习专用&quot;&gt;&lt;/a&gt;C#知识点提炼期末复习专用&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;根据内部消息称，有三类题型：&lt;br&gt;程序阅
      
    
    </summary>
    
      <category term="C#" scheme="http://hys666666.github.io/categories/C/"/>
    
    
      <category term="复习" scheme="http://hys666666.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeSong Blog</title>
  
  <subtitle>Welcome to my world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codesong.work/"/>
  <updated>2019-08-23T08:45:20.210Z</updated>
  <id>https://codesong.work/</id>
  
  <author>
    <name>CodeSong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简述Java中内存的划分(学习笔记)</title>
    <link href="https://codesong.work/posts/d9fe9f0c.html"/>
    <id>https://codesong.work/posts/d9fe9f0c.html</id>
    <published>2019-08-23T06:41:39.000Z</published>
    <updated>2019-08-23T08:45:20.210Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><strong>任何计算机程序，如果想要运行，都需要开辟一块内存空间。</strong></p></blockquote><hr><p>&emsp;&emsp;计算机整体的内存都是由操作系统来进行管理的，所以Java程序运行需要向计算机操作系统申请一块内存。这块专属内存被划分为了五部分，这样一来每一小块内存能被更好的使用和分门别类来管理。</p><h1 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h1><p>&emsp;&emsp;栈中执行每个方法的时候，方法中的局部变量都会存在这块内存中。jvm会创建一个栈帧来存储局部变量表，栈帧还存有：操作数栈，动态链接，方法出口等信息。</p><h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><p>&emsp;&emsp;堆是Java对象在内存中的存储区域，凡是用new出来的东西都在这里面。Java中的对象和数组都被分配在堆中。</p><p>堆内存里面的数据，都有默认值。规则：</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">整型</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">浮点型</td><td style="text-align:center">0.0</td></tr><tr><td style="text-align:center">字符型</td><td style="text-align:center">‘\u0000’</td></tr><tr><td style="text-align:center">布尔型</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">引用类型</td><td style="text-align:center">null</td></tr></tbody></table><h1 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h1><p>&emsp;&emsp;它用于存储已被虚拟机加载的类信息，常量，静态变量，方法的信息，即时编译器编译后的代码等数据。</p><blockquote><p><strong>注意：仅仅是包含了类的相关信息</strong></p></blockquote><h1 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h1><p>&emsp;&emsp;与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的本地方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</p><p>&emsp;&emsp;很多的算法或者一个功能的实现，都被java封装到了本地方法中，程序直接通过调用本地的方法就行了，本地方法栈就是用来存放这种方法的，实现该功能的代码可能是C也可能是C++,反正不一定就是java实现的。</p><h1 id="Program-Count-Register（PC寄存器，程序计数器）"><a href="#Program-Count-Register（PC寄存器，程序计数器）" class="headerlink" title="Program Count Register（PC寄存器，程序计数器）"></a>Program Count Register（PC寄存器，程序计数器）</h1><p>&emsp;&emsp;指示Java虚拟机下一条需要执行的字节码指令。</p><p>&emsp;&emsp;程序计数器是一块较小的内存区域，作用可以看做是当前线程执行的字节码的位置指示器。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成。</p><hr><p>&emsp;&emsp;以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。 所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何计算机程序，如果想要运行，都需要开辟一块内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;计算机整体的内存都是由操作系统来进行管理的，所以Java程序运行需要向计
      
    
    </summary>
    
      <category term="Java" scheme="https://codesong.work/categories/Java/"/>
    
    
      <category term="学习笔记" scheme="https://codesong.work/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java内存" scheme="https://codesong.work/tags/Java%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>C#复习知识点提炼</title>
    <link href="https://codesong.work/posts/2b58aa48.html"/>
    <id>https://codesong.work/posts/2b58aa48.html</id>
    <published>2019-04-29T13:53:00.000Z</published>
    <updated>2019-08-22T12:46:00.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-知识点提炼期末复习专用"><a href="#C-知识点提炼期末复习专用" class="headerlink" title="C#知识点提炼期末复习专用"></a>C#知识点提炼期末复习专用</h1><hr><p>根据内部消息称，有三类题型：<br>程序阅读题：2题<br>简答题：2题 （主要是对概念的考查）<br>编程题：暂定2-3题  </p><p>复习要点：<br><strong>.net framework</strong><br>通用语言开发环境、.NET基础类库、.NET开发语言、visual studio.NET 集成开发环境</p><hr><h2 id="C-的特点"><a href="#C-的特点" class="headerlink" title="C#的特点"></a>C#的特点</h2><ol><li><p>语法简介</p></li><li><p>彻底的面向对象</p></li><li><p>与Web应用紧密结合</p></li><li><p>强大的安全机制</p></li><li><p>完善的错误、异常处理机制</p></li><li><p>灵活的版本处理技术</p></li><li><p>兼容性</p></li><li><p>（老师加的）全方位的跨平台支持</p></li></ol><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><ol><li>跨平台 </li><li>开源</li></ol><h2 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h2><p>值类型：<strong>该类型的数据长度固定，存放于栈内</strong></p><p>引用类型：<strong>该类型的数据长度可变，存放于堆内</strong></p><h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><ol><li><p>abstract 抽象类，不能创建该类的实例，只能作为基类</p></li><li><p>internal 老师说，在同一程序内部访问而非指某一个命名空间内部，其它命名空间用using来使用</p></li><li><p>new 用于声明嵌套的类</p></li><li><p>private 用于声明私有嵌套类，只能在定义它的类中访问这个类</p></li><li><p>protected 用于声明保护型嵌套类，只能在定义它的类以及该类的子类中访问这个类</p></li><li><p>public 该类可以被任何其它类访问</p></li><li><p>sealed 该类不能被继承</p></li></ol><h2 id="类成员修饰符有四类"><a href="#类成员修饰符有四类" class="headerlink" title="类成员修饰符有四类"></a>类成员修饰符有四类</h2><ol><li><p>public 公有成员</p></li><li><p>Private 私有成员</p></li><li><p>Protected 保护成员</p></li><li><p>Internal 内部成员</p></li></ol><h1 id="构造函数、析构函数"><a href="#构造函数、析构函数" class="headerlink" title="构造函数、析构函数"></a>构造函数、析构函数</h1><p>&emsp;&emsp;构造函数与类名相同，开头public，无返回值，主要对类的实例初始化，实例类时自动执行</p><p>&emsp;&emsp;析构函数名比析构函数多加了一个符号 ’~’，与构造函数区别在于，该函数在对象销毁时执行</p><h1 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h1><p><strong>继承</strong>本质是代码重用（具体懒得写）</p><p><strong>多态</strong>就是将子类赋值给父类，可以在父类中通过调用抽象方法来实现子类的具体功能</p><p><strong>ASP.NET,page</strong>实例的生命周期自己找去</p><h1 id="方法的重载与区分"><a href="#方法的重载与区分" class="headerlink" title="方法的重载与区分"></a>方法的重载与区分</h1><p>&emsp;&emsp;重载指的是允许存在多个同名参数，而这些函数的参数呢，是不一样的，可以是类型不一样可以是个数不一样，然后再调用这个方法时，编译器可以按照输入的参数去调用适当的方法</p><h2 id="装箱和拆箱。重载。"><a href="#装箱和拆箱。重载。" class="headerlink" title="装箱和拆箱。重载。"></a>装箱和拆箱。重载。</h2><p>说简单点就是：把一个具体的子类对象赋值给了父类对象就可以理解为发生了装箱操作，将父类对象强转为具体的子类对象就是拆箱操作</p><p>里式转换法则：父类中包含的是子类对象，则可以强转成文子类对象</p><p>秀操作专用知识点</p><h1 id="c-面向对象的思想。"><a href="#c-面向对象的思想。" class="headerlink" title="c#面向对象的思想。"></a>c#面向对象的思想。</h1><p>面向对象的思想很简单，就是对象咯（似乎是废话）</p><p>面向对象是一种模块化的、以对象为基础的设计思想，现在被广泛应用于软件设计领域。</p><p>基本单元就是<strong>对象！对象！对象！</strong></p><p><strong>对象</strong>就是封装起来的代码块，功能模块？应该是的</p><p>本篇文章就是它的思想吧，太扯了跳过。。。</p><p>关键字 <strong>class</strong> 的使用和概念<br>定义类时需要用到的关键字</p><p>类是引用类型，在堆上分配地址</p><p>关键字<strong>struct</strong>的使用和概念<br>定义结构体是需要用到的关键字</p><p>结构体是值类型，在堆栈上分配地址（据网上所说堆栈就是栈，只是换了个抽象的名字，没具体了解）</p><h1 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h1><p>抽象方法：只包含了方法定义，但没有具体实现的方法，需要其子类或者子类的子类来具体实现。</p><p>抽象类：含有一个或多个抽象方法的类称为抽象类。抽象类不能被实例化，这是因为它包含了没有具体实现的方法。</p><ol><li>使用abstract关键字来定义抽象类和方法，使用格式如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SB</span> //定义了抽象类<span class="title">SB</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">DSB</span><span class="params">()</span></span>; <span class="comment">//定义了抽象方法DSB</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>子类继承抽象父类后，可以使用override关键字覆盖父类中的抽象方法，并做具体的实现，格式如下：</li></ol><p><strong>。。。。没有格式，把上面的abstract换成override就ojbk了</strong></p><h1 id="接口和类"><a href="#接口和类" class="headerlink" title="接口和类"></a>接口和类</h1><p>就是定义一组数据结构，通过这组数据结构可以调用组件对象的功能。反正和抽象类差不多，可以看成是类的模板</p><p>接口的特点、定义和使用<br>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SB</span>//关键字<span class="title">interface</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">DSB</span><span class="params">()</span></span>;<span class="comment">//接口已规定是public，声明时不需要访问级别修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以继承多个接口，实现接口中的方法不需要使用关键字“override”</p><p><strong>接口也可以实现多态，这和抽象类一样</strong>，书上一句很无语的话。。。</p><p>使用的时候就是子类继承啦。。。</p><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别?"></a>抽象类和接口的区别?</h1><ol><li><p>抽象类除了拥有抽象成员以外，还可以拥有非抽象成员；而接口所有成员都是抽象的；</p></li><li><p>抽象成员可以是私有的，而接口一般都是公开的（不太清楚这里的“一般”，那么“不一般”又是什么呢？）；</p></li><li><p>接口中不能含有构造函数、析构函数、静态成员、和常量；</p></li><li><p>C#只支持单继承，一个子类只能继承一个父类。而一个子类却能继承多个接口</p></li></ol><h1 id="Using-关键字两种用法"><a href="#Using-关键字两种用法" class="headerlink" title="Using 关键字两种用法"></a>Using 关键字两种用法</h1><p>一种是引用命名空间，另一种是。。。老师课堂上的忘了，但网上查了，如下：</p><p>定义一个范围，在范围结束时处理对象。</p><p>场景：</p><p>当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要离开了这个代码段就自动调用这个类实例的<strong>Dispose</strong>。</p><p>要达到这样的目的，用<strong>try…catch</strong>来捕捉异常也是可以的，但用<strong>using</strong>也很方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using (Class1 cls1 = <span class="keyword">new</span> Class1(), cls2 = <span class="keyword">new</span> Class1())</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the code using cls1, cls2</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// call the Dispose on cls1 and cls2</span></span><br></pre></td></tr></table></figure><p>网上说还有一种功能给命名空间起个“外号”。。。</p><h1 id="关键字new"><a href="#关键字new" class="headerlink" title="关键字new"></a>关键字new</h1><p>&emsp;&emsp;C#不允许在安全代码中使用指针，因此要处理对中的数据就需要使用引用类型，使用new关键字实例化引用数据类型的对象，并指向堆中的对象数据。</p><p>内置的引用类型有两种分别是System.Object和System.String</p><p>&emsp;&emsp;C#中数组也被看作一个带有方法和属性的对象，所以定义数组时，也需要用到new</p><h1 id="多态的特性及意义！"><a href="#多态的特性及意义！" class="headerlink" title="多态的特性及意义！"></a>多态的特性及意义！</h1><p>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。</p><p>对不同类的对象发出相同的消息将会有不同的行为，就是同一个处理手段可以用来处理多种不同的情况</p><p>没有继承就没有多态！</p><ol><li><p>提高了代码的维护性(继承保证)</p></li><li><p>提高了代码的扩展性(由多态保证)</p></li></ol><p>全是网上查的，这算是特性和意义吧。。。</p><h1 id="Namespace关键字"><a href="#Namespace关键字" class="headerlink" title="Namespace关键字"></a>Namespace关键字</h1><p>&emsp;&emsp;简单的说就是定义命名空间用的关键字，往复杂了说呢，说了也不懂，跳过</p><h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>流是.NET操作文件的基本类。对文件的输入输出操作都要用到流。流分为输入流和输出流。</p><p>懒得写了，课本165页。。。</p><p><strong><em>书本重点例题：p32   p82p83  p89-91  p97 p99 p117  p113（改写后的代码） p175</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-知识点提炼期末复习专用&quot;&gt;&lt;a href=&quot;#C-知识点提炼期末复习专用&quot; class=&quot;headerlink&quot; title=&quot;C#知识点提炼期末复习专用&quot;&gt;&lt;/a&gt;C#知识点提炼期末复习专用&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;根据内部消息称，有三类题型：&lt;br&gt;程序阅
      
    
    </summary>
    
      <category term="C#" scheme="https://codesong.work/categories/C/"/>
    
    
      <category term="复习" scheme="https://codesong.work/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
</feed>

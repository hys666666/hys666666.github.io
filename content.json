{"meta":{"title":"CodeSong By Blog","subtitle":"Welcome to my world!","description":"火把倒下，火焰依然向上","author":"CodeSong","url":"https://codesong.work","root":"/"},"pages":[{"title":"关于","date":"2019-08-16T02:25:50.000Z","updated":"2020-03-28T06:23:56.801Z","comments":false,"path":"about/index.html","permalink":"https://codesong.work/about/index.html","excerpt":"","text":"生命在于折腾，博客终于耍起来啦！开森！ 可以做少一点，但是不能什么都不做 本博客由 Hexo 强力驱动，主题：NexT.Pisces v5.1.4 本博客于2019年8月搭建"},{"title":"分类","date":"2019-08-16T01:57:38.000Z","updated":"2020-03-28T06:23:37.489Z","comments":false,"path":"categories/index.html","permalink":"https://codesong.work/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-16T01:58:57.000Z","updated":"2020-03-28T06:21:51.816Z","comments":false,"path":"tags/index.html","permalink":"https://codesong.work/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"蓝桥2013真题C++B组（三）","slug":"蓝桥2013真题C-B组（三）","date":"2020-04-22T10:31:43.000Z","updated":"2020-04-22T11:01:45.846Z","comments":true,"path":"posts/c73a0382.html","link":"","permalink":"https://codesong.work/posts/c73a0382.html","excerpt":"","text":"第39级台阶&emsp;&emsp;小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级! 站在台阶前，他突然又想着一个问题：&emsp;&emsp;如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？ 很明显是类似斐波那契数的东西f(n){return f(n-1)+f(n-2);}，可以用递归来做，模拟迈步子，当把所有台阶都上完时（每一步都可以迈一个台阶或者两个台阶），再判断是否是偶数步数即可，以下为代码部分：12345678910111213141516171819#include &lt;cstdio&gt;/***************************** * My Blog: CodeSong.work * ***************************** */int ans=0;void f(int n,int step)&#123;//n为剩余台阶数，step为已走步数 if(n&lt;0) return ; if(n==0&amp;&amp;step%2==0) ans++; f(n-1,step+1); f(n-2,step+1);&#125;int main()&#123; f(39,0);//初始总共有39级台阶，已走的步数为零 printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"蓝桥杯真题","slug":"蓝桥杯真题","permalink":"https://codesong.work/categories/蓝桥杯真题/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://codesong.work/tags/蓝桥杯/"},{"name":"算法","slug":"算法","permalink":"https://codesong.work/tags/算法/"},{"name":"C/C++","slug":"C-C","permalink":"https://codesong.work/tags/C-C/"}]},{"title":"蓝桥2013真题C++B组（二）","slug":"蓝桥2013真题C-B组（二）","date":"2020-04-22T10:31:36.000Z","updated":"2020-04-22T11:04:33.594Z","comments":true,"path":"posts/8a24a0d0.html","link":"","permalink":"https://codesong.work/posts/8a24a0d0.html","excerpt":"","text":"马虎的算式小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。有一次，老师出的题目是：36 x 495 = ?他却给抄成了：396 x 45 = ?但结果却很戏剧性，他的答案竟然是对的！！因为 36 * 495 = 396 * 45 = 17820类似这样的巧合情况可能还有很多，比如：27 * 594 = 297 * 5假设 a b c d e 代表1~9不同的5个数字（注意是各不相同的数字，且不含0）能满足形如： ab * cde = adb * ce 这样的算式一共有多少种呢？请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。答案直接通过浏览器提交。注意：只提交一个表示最终统计种类数的数字，不要提交解答过程或其它多余的内容。能满足形如：ab * cde = adb * ce这样的算式一共有多少种？ 既然左右替换算是一种，直接枚举出所有数的组合，然后判断计算结果是否相等即可，非常简单，以下为代码部分： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;/***************************** * My Blog: CodeSong.work * ***************************** */int main()&#123; int ans = 0;//记录答案 for(int a=1;a&lt;10;++a)&#123; for (int b = 1; b &lt; 10; b++) &#123; if(b==a) continue; for (int c = 1; c &lt; 10; c++) &#123; if(c==a||c==b) continue; for (int d = 1; d &lt; 10; d++) &#123; if(d==a||d==b||d==c) continue; for (int e = 1; e &lt; 10; e++) &#123; if(e==a||e==b||e==c||e==d) continue; //ab * cde = adb * ce int t1 = (a*10 + b)*(c*100+d*10+e); int t2 = (a*100+d*10+b)*(c*10+e); if(t1==t2) ans++; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"蓝桥杯真题","slug":"蓝桥杯真题","permalink":"https://codesong.work/categories/蓝桥杯真题/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://codesong.work/tags/蓝桥杯/"},{"name":"算法","slug":"算法","permalink":"https://codesong.work/tags/算法/"},{"name":"C/C++","slug":"C-C","permalink":"https://codesong.work/tags/C-C/"}]},{"title":"蓝桥2013真题C++B组（一）","slug":"蓝桥2013真题C-B组（一）","date":"2020-04-22T10:31:26.000Z","updated":"2020-04-22T10:39:53.048Z","comments":true,"path":"posts/ba324c08.html","link":"","permalink":"https://codesong.work/posts/ba324c08.html","excerpt":"","text":"高斯日记&emsp;&emsp;大数学家高斯有个好习惯：无论如何都要记日记。他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210。后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。&emsp;&emsp;这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？&emsp;&emsp;高斯出生于：1777年4月30日。在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。&emsp;&emsp;高斯获得博士学位的那天日记上标着：8113。请你算出高斯获得博士学位的年月日。提交答案的格式是: yyyy-mm-dd, 例如: 1980-03-21 这道题非常简单，由于只提交一个日期，那直接利用程序从出生那天开始跑一遍要求的次数就能够得到答案了。有两点：一、需要检查高斯出生的当天算不算是一天，可以拿题目中的例子来测试你的算法（这一步必须检查不然错了冤死了）二、由于日期有一些规定，所以需要特别处理：闰年，平年，大月，小月，月末，年末； 关于闰年，定制闰年规则不是随意设置的。 首先我们要知道，年的概念，是地球围绕太阳一周的时间（所谓公转周期）称为一年，这个周期是相当稳定的，很长时间也不会变动1秒，但是很遗憾zhidao的是这个周期并不能被一天的时间整除，真正的一年其实是365.2423天（目前）。 所以，如果每年定义为365天的话，1年就会多出0.2423天，4年就会多出0.9692天，非常接近1天，这样闰年就出现了，也就是每4年要有1年设置为366天，来抵消这多出的1天。规则为：(1)如果年份能被4整除，则该年计为闰年 可是，假如不做调整的话，当400年的时候，累计才多出96.92天，闰年的设置却多出来100天，所权以要在400年内，再撤销3个闰年。怎么撤销呢？就有了下面这个规则：(2)如果年份能被100整除，则不计为闰年 问题又来了，400年里有4个，又少了一个，所以再加一个规则就是：(3)如果年份能被400整除，则计为闰年 这样每400年里设置了97个闰年，误差被调整到400年仅有0.08天，而设置规则也并不是很麻烦，所以一直沿用了下来。* 特别注意本题难点仅在逻辑判断,以下为代码部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;/***************************** * My Blog: CodeSong.work * ***************************** */bool isLeapYear(int n)&#123; //返回是否是闰年的判断 return ((n % 4 == 0 &amp;&amp; n % 100 != 0) || n % 400 == 0);&#125;int main()&#123; int year = 1777;//年 int month = 4;//月 int day = 30;//日 int dSum = 8113;//天数 //月份的逻辑判断为容易出错的地方,还有日期的改变 while (--dSum) &#123;//先判断是否为月底 if (month == 12 &amp;&amp; day == 31) &#123; //判断是否是一年中最后的一天，year加1，month和day重置为1 year += 1; month = 1; day = 1; continue; &#125; if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10) &amp;&amp; day == 31) &#123; //判断是否是大月中的最后一天 month += 1; day = 1; continue; &#125; if ((month == 4 || month == 6 || month == 9 || month == 11) &amp;&amp; day == 30) &#123; //判断是否是小月中的最后一天 month += 1; day = 1; continue; &#125; if (month == 2 &amp;&amp; isLeapYear(year) &amp;&amp; day == 29) &#123; //单独处理闰年的月底 month += 1; day = 1; continue; &#125; if (month == 2 &amp;&amp; !isLeapYear(year) &amp;&amp; day==28) &#123; //单独处理平年的月底 month += 1; day = 1; continue; &#125; day++;//非月底则day直接增加一 &#125; printf(\"%d-%d-%d\\n\", year, month, day); return 0;&#125;","categories":[{"name":"蓝桥杯真题","slug":"蓝桥杯真题","permalink":"https://codesong.work/categories/蓝桥杯真题/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://codesong.work/tags/蓝桥杯/"},{"name":"算法","slug":"算法","permalink":"https://codesong.work/tags/算法/"},{"name":"C/C++","slug":"C-C","permalink":"https://codesong.work/tags/C-C/"}]},{"title":"个人博客部署免费的https安全证书","slug":"个人博客部署免费的https安全证书","date":"2020-03-26T12:59:04.000Z","updated":"2020-04-22T10:58:37.194Z","comments":true,"path":"posts/ce68fd7a.html","link":"","permalink":"https://codesong.work/posts/ce68fd7a.html","excerpt":"","text":"个人博客怎么部署免费的https安全证书？&emsp;&emsp;首先需要去阿里云申请一个免费的安全证书 我是一个超链接 选择免费的证书： 免费购买后，在证书控制台申请证书：后面接着提交信息，验证，几分钟就会成功了不再阐述 将证书部署到服务器上服务器系统：Ubuntu Web服务器：Apache2 前提条件 从SSL证书控制台下载相应版本的证书 服务器已安装Open SLL（反正我的是默认有了的） 操作步骤在Apache2目录下创建个目录并且将证书文件复制进去mkdir /ect/apache2/ssl cp *public.crt /etc/apache2/ssl cp *Name.key /etc/apache2/ssl 启用SSL模块sudo a2enmod ssl 修改SSL配置文件default-ssl.confvi /etc/apache2/sites-available/default-ssl.conf 参数修改如下：123456&lt;IfModules mod_ssl.c&gt;&lt;VirtualHost *:443&gt; ServerName #修改为证书绑定的域名www.YourDomainName.com。SSLCertificateFile /etc/apache2/ssl/www.YourDomainName_public.crt #将/etc/apache2/ssl/www.YourDomainName.com_public.crt替换为证书文件路径+证书文件名。SSLCertificateKeyFile /etc/ssl/apache2/www.YourDomainName.com.key #将/etc/apache2/ssl/www.YourDomainName.com.key替换为证书密钥文件路径+证书密钥文件名。SSLCertificateChainFile /etc/apache2/ssl/www.YourDomainName.com_chain.crt #将/etc/apache2/ssl/www.YourDomainName.com_chain.crt替换为证书链文件路径+证书链文件名。 sites-available：该目录存放的是可用的虚拟主机； sites-enabled：该目录存放的是已经启用的虚拟主机。 将default-ssl.conf映射至/etc/apache2/sites-enabled文件夹中建立软链接、实现二者之间的自动关联sudo ln -s /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled/001-ssl.conf 重新加载Apache2配置文件sudo /etc/init.d/apache2 force-reload 重新启动Apache2sudo /etc/init.d/apache2 restart 或者 sudo apache2ctl restart &emsp;&emsp;服务器安装https安全证书完成！","categories":[{"name":"博客","slug":"博客","permalink":"https://codesong.work/categories/博客/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"https://codesong.work/tags/ssl/"},{"name":"https","slug":"https","permalink":"https://codesong.work/tags/https/"},{"name":"安全证书","slug":"安全证书","permalink":"https://codesong.work/tags/安全证书/"}]},{"title":"Java中内存的划分-学习笔记","slug":"Java中内存的划分-学习笔记","date":"2019-08-23T10:44:04.000Z","updated":"2020-04-22T10:57:09.121Z","comments":true,"path":"posts/3a8013f5.html","link":"","permalink":"https://codesong.work/posts/3a8013f5.html","excerpt":"","text":"任何计算机程序，如果想要运行，都需要开辟一块内存空间。 &emsp;&emsp;计算机整体的内存都是由操作系统来进行管理的，所以Java程序运行需要向计算机操作系统申请一块内存。这块专属内存被划分为了五部分，这样一来每一小块内存能被更好的使用和分门别类来管理。 虚拟机栈（VM Stack）&emsp;&emsp;栈中执行每个方法的时候，方法中的局部变量都会存在这块内存中。jvm会创建一个栈帧来存储局部变量表，栈帧还存有：操作数栈，动态链接，方法出口等信息。 堆（Heap）&emsp;&emsp;堆是Java对象在内存中的存储区域，凡是用new出来的东西都在这里面。Java中的对象和数组都被分配在堆中。 堆内存里面的数据，都有默认值。规则： 数据类型 默认值 整型 0 浮点型 0.0 字符型 ‘\\u0000’ 布尔型 false 引用类型 null 方法区(Method Area) 它用于存储已被虚拟机加载的类信息，常量，静态变量，方法的信息，即时编译器编译后的代码等数据。 注意：仅仅是包含了类的相关信息 本地方法栈（Native Method Stack） 与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的本地方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 很多的算法或者一个功能的实现，都被java封装到了本地方法中，程序直接通过调用本地的方法就行了，本地方法栈就是用来存放这种方法的，实现该功能的代码可能是C也可能是C++,反正不一定就是java实现的。 Program Count Register（PC寄存器，程序计数器） 指示Java虚拟机下一条需要执行的字节码指令。 程序计数器是一块较小的内存区域，作用可以看做是当前线程执行的字节码的位置指示器。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成。 以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。 所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。","categories":[],"tags":[]},{"title":"C#复习知识点提炼","slug":"C-复习知识点提炼","date":"2019-04-29T13:53:00.000Z","updated":"2019-08-22T12:46:00.821Z","comments":true,"path":"posts/2b58aa48.html","link":"","permalink":"https://codesong.work/posts/2b58aa48.html","excerpt":"","text":"C#知识点提炼期末复习专用 根据内部消息称，有三类题型：程序阅读题：2题简答题：2题 （主要是对概念的考查）编程题：暂定2-3题 复习要点：.net framework通用语言开发环境、.NET基础类库、.NET开发语言、visual studio.NET 集成开发环境 C#的特点 语法简介 彻底的面向对象 与Web应用紧密结合 强大的安全机制 完善的错误、异常处理机制 灵活的版本处理技术 兼容性 （老师加的）全方位的跨平台支持 ASP.NET Core 跨平台 开源 值类型和引用类型的区别值类型：该类型的数据长度固定，存放于栈内 引用类型：该类型的数据长度可变，存放于堆内 类的修饰符 abstract 抽象类，不能创建该类的实例，只能作为基类 internal 老师说，在同一程序内部访问而非指某一个命名空间内部，其它命名空间用using来使用 new 用于声明嵌套的类 private 用于声明私有嵌套类，只能在定义它的类中访问这个类 protected 用于声明保护型嵌套类，只能在定义它的类以及该类的子类中访问这个类 public 该类可以被任何其它类访问 sealed 该类不能被继承 类成员修饰符有四类 public 公有成员 Private 私有成员 Protected 保护成员 Internal 内部成员 构造函数、析构函数&emsp;&emsp;构造函数与类名相同，开头public，无返回值，主要对类的实例初始化，实例类时自动执行 &emsp;&emsp;析构函数名比析构函数多加了一个符号 ’~’，与构造函数区别在于，该函数在对象销毁时执行 继承、多态继承本质是代码重用（具体懒得写） 多态就是将子类赋值给父类，可以在父类中通过调用抽象方法来实现子类的具体功能 ASP.NET,page实例的生命周期自己找去 方法的重载与区分&emsp;&emsp;重载指的是允许存在多个同名参数，而这些函数的参数呢，是不一样的，可以是类型不一样可以是个数不一样，然后再调用这个方法时，编译器可以按照输入的参数去调用适当的方法 装箱和拆箱。重载。说简单点就是：把一个具体的子类对象赋值给了父类对象就可以理解为发生了装箱操作，将父类对象强转为具体的子类对象就是拆箱操作 里式转换法则：父类中包含的是子类对象，则可以强转成文子类对象 秀操作专用知识点 c#面向对象的思想。面向对象的思想很简单，就是对象咯（似乎是废话） 面向对象是一种模块化的、以对象为基础的设计思想，现在被广泛应用于软件设计领域。 基本单元就是对象！对象！对象！ 对象就是封装起来的代码块，功能模块？应该是的 本篇文章就是它的思想吧，太扯了跳过。。。 关键字 class 的使用和概念定义类时需要用到的关键字 类是引用类型，在堆上分配地址 关键字struct的使用和概念定义结构体是需要用到的关键字 结构体是值类型，在堆栈上分配地址（据网上所说堆栈就是栈，只是换了个抽象的名字，没具体了解） 抽象类和抽象方法抽象方法：只包含了方法定义，但没有具体实现的方法，需要其子类或者子类的子类来具体实现。 抽象类：含有一个或多个抽象方法的类称为抽象类。抽象类不能被实例化，这是因为它包含了没有具体实现的方法。 使用abstract关键字来定义抽象类和方法，使用格式如下 1234567public abstract class SB //定义了抽象类SB&#123;public abstract void DSB(); //定义了抽象方法DSB&#125; 子类继承抽象父类后，可以使用override关键字覆盖父类中的抽象方法，并做具体的实现，格式如下： 。。。。没有格式，把上面的abstract换成override就ojbk了 接口和类就是定义一组数据结构，通过这组数据结构可以调用组件对象的功能。反正和抽象类差不多，可以看成是类的模板 接口的特点、定义和使用定义格式： 12345678public interface SB//关键字interface&#123;Int DSB();//接口已规定是public，声明时不需要访问级别修饰&#125; 子类可以继承多个接口，实现接口中的方法不需要使用关键字“override” 接口也可以实现多态，这和抽象类一样，书上一句很无语的话。。。 使用的时候就是子类继承啦。。。 抽象类和接口的区别? 抽象类除了拥有抽象成员以外，还可以拥有非抽象成员；而接口所有成员都是抽象的； 抽象成员可以是私有的，而接口一般都是公开的（不太清楚这里的“一般”，那么“不一般”又是什么呢？）； 接口中不能含有构造函数、析构函数、静态成员、和常量； C#只支持单继承，一个子类只能继承一个父类。而一个子类却能继承多个接口 Using 关键字两种用法一种是引用命名空间，另一种是。。。老师课堂上的忘了，但网上查了，如下： 定义一个范围，在范围结束时处理对象。 场景： 当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要离开了这个代码段就自动调用这个类实例的Dispose。 要达到这样的目的，用try…catch来捕捉异常也是可以的，但用using也很方便。 1234567using (Class1 cls1 = new Class1(), cls2 = new Class1())&#123; // the code using cls1, cls2&#125; // call the Dispose on cls1 and cls2 网上说还有一种功能给命名空间起个“外号”。。。 关键字new&emsp;&emsp;C#不允许在安全代码中使用指针，因此要处理对中的数据就需要使用引用类型，使用new关键字实例化引用数据类型的对象，并指向堆中的对象数据。 内置的引用类型有两种分别是System.Object和System.String &emsp;&emsp;C#中数组也被看作一个带有方法和属性的对象，所以定义数组时，也需要用到new 多态的特性及意义！多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。 对不同类的对象发出相同的消息将会有不同的行为，就是同一个处理手段可以用来处理多种不同的情况 没有继承就没有多态！ 提高了代码的维护性(继承保证) 提高了代码的扩展性(由多态保证) 全是网上查的，这算是特性和意义吧。。。 Namespace关键字&emsp;&emsp;简单的说就是定义命名空间用的关键字，往复杂了说呢，说了也不懂，跳过 流流是.NET操作文件的基本类。对文件的输入输出操作都要用到流。流分为输入流和输出流。 懒得写了，课本165页。。。 书本重点例题：p32 p82p83 p89-91 p97 p99 p117 p113（改写后的代码） p175","categories":[{"name":"C#","slug":"C","permalink":"https://codesong.work/categories/C/"}],"tags":[{"name":"复习","slug":"复习","permalink":"https://codesong.work/tags/复习/"}]}]}
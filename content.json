{"meta":{"title":"CodeSong blog","subtitle":"Welcome!","description":"火把倒下，火焰依然向上","author":"CodeSong","url":"https://codesong.work","root":"/"},"pages":[{"title":"标签","date":"2019-08-16T01:58:57.000Z","updated":"2019-08-16T02:27:28.769Z","comments":true,"path":"tags/index.html","permalink":"https://codesong.work/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-16T02:25:50.000Z","updated":"2019-08-23T10:20:22.015Z","comments":true,"path":"about/index.html","permalink":"https://codesong.work/about/index.html","excerpt":"","text":"生命在于折腾，博客终于耍起来啦！开森！ 可以做少一点，但是不能什么都不做 一名在校大学生的个人博客，本博客由 Hexo 强力驱动，主题：NexT.Pisces v5.1.4 本博客于2019年8月搭建"},{"title":"分类","date":"2019-08-16T01:57:38.000Z","updated":"2019-08-16T02:26:37.031Z","comments":true,"path":"categories/index.html","permalink":"https://codesong.work/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"简述Java中内存的划分(学习笔记)","slug":"Java中内存的划分-学习笔记","date":"2019-08-23T06:41:39.000Z","updated":"2019-08-23T08:45:20.210Z","comments":true,"path":"posts/d9fe9f0c.html","link":"","permalink":"https://codesong.work/posts/d9fe9f0c.html","excerpt":"","text":"任何计算机程序，如果想要运行，都需要开辟一块内存空间。 &emsp;&emsp;计算机整体的内存都是由操作系统来进行管理的，所以Java程序运行需要向计算机操作系统申请一块内存。这块专属内存被划分为了五部分，这样一来每一小块内存能被更好的使用和分门别类来管理。 虚拟机栈（VM Stack）&emsp;&emsp;栈中执行每个方法的时候，方法中的局部变量都会存在这块内存中。jvm会创建一个栈帧来存储局部变量表，栈帧还存有：操作数栈，动态链接，方法出口等信息。 堆（Heap）&emsp;&emsp;堆是Java对象在内存中的存储区域，凡是用new出来的东西都在这里面。Java中的对象和数组都被分配在堆中。 堆内存里面的数据，都有默认值。规则： 数据类型 默认值 整型 0 浮点型 0.0 字符型 ‘\\u0000’ 布尔型 false 引用类型 null 方法区(Method Area)&emsp;&emsp;它用于存储已被虚拟机加载的类信息，常量，静态变量，方法的信息，即时编译器编译后的代码等数据。 注意：仅仅是包含了类的相关信息 本地方法栈（Native Method Stack）&emsp;&emsp;与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的本地方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 &emsp;&emsp;很多的算法或者一个功能的实现，都被java封装到了本地方法中，程序直接通过调用本地的方法就行了，本地方法栈就是用来存放这种方法的，实现该功能的代码可能是C也可能是C++,反正不一定就是java实现的。 Program Count Register（PC寄存器，程序计数器）&emsp;&emsp;指示Java虚拟机下一条需要执行的字节码指令。 &emsp;&emsp;程序计数器是一块较小的内存区域，作用可以看做是当前线程执行的字节码的位置指示器。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成。 &emsp;&emsp;以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。 所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。","categories":[{"name":"Java","slug":"Java","permalink":"https://codesong.work/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codesong.work/tags/学习笔记/"},{"name":"Java内存","slug":"Java内存","permalink":"https://codesong.work/tags/Java内存/"}]},{"title":"C#复习知识点提炼","slug":"C-复习知识点提炼","date":"2019-04-29T13:53:00.000Z","updated":"2019-08-22T12:46:00.821Z","comments":true,"path":"posts/2b58aa48.html","link":"","permalink":"https://codesong.work/posts/2b58aa48.html","excerpt":"","text":"C#知识点提炼期末复习专用 根据内部消息称，有三类题型：程序阅读题：2题简答题：2题 （主要是对概念的考查）编程题：暂定2-3题 复习要点：.net framework通用语言开发环境、.NET基础类库、.NET开发语言、visual studio.NET 集成开发环境 C#的特点 语法简介 彻底的面向对象 与Web应用紧密结合 强大的安全机制 完善的错误、异常处理机制 灵活的版本处理技术 兼容性 （老师加的）全方位的跨平台支持 ASP.NET Core 跨平台 开源 值类型和引用类型的区别值类型：该类型的数据长度固定，存放于栈内 引用类型：该类型的数据长度可变，存放于堆内 类的修饰符 abstract 抽象类，不能创建该类的实例，只能作为基类 internal 老师说，在同一程序内部访问而非指某一个命名空间内部，其它命名空间用using来使用 new 用于声明嵌套的类 private 用于声明私有嵌套类，只能在定义它的类中访问这个类 protected 用于声明保护型嵌套类，只能在定义它的类以及该类的子类中访问这个类 public 该类可以被任何其它类访问 sealed 该类不能被继承 类成员修饰符有四类 public 公有成员 Private 私有成员 Protected 保护成员 Internal 内部成员 构造函数、析构函数&emsp;&emsp;构造函数与类名相同，开头public，无返回值，主要对类的实例初始化，实例类时自动执行 &emsp;&emsp;析构函数名比析构函数多加了一个符号 ’~’，与构造函数区别在于，该函数在对象销毁时执行 继承、多态继承本质是代码重用（具体懒得写） 多态就是将子类赋值给父类，可以在父类中通过调用抽象方法来实现子类的具体功能 ASP.NET,page实例的生命周期自己找去 方法的重载与区分&emsp;&emsp;重载指的是允许存在多个同名参数，而这些函数的参数呢，是不一样的，可以是类型不一样可以是个数不一样，然后再调用这个方法时，编译器可以按照输入的参数去调用适当的方法 装箱和拆箱。重载。说简单点就是：把一个具体的子类对象赋值给了父类对象就可以理解为发生了装箱操作，将父类对象强转为具体的子类对象就是拆箱操作 里式转换法则：父类中包含的是子类对象，则可以强转成文子类对象 秀操作专用知识点 c#面向对象的思想。面向对象的思想很简单，就是对象咯（似乎是废话） 面向对象是一种模块化的、以对象为基础的设计思想，现在被广泛应用于软件设计领域。 基本单元就是对象！对象！对象！ 对象就是封装起来的代码块，功能模块？应该是的 本篇文章就是它的思想吧，太扯了跳过。。。 关键字 class 的使用和概念定义类时需要用到的关键字 类是引用类型，在堆上分配地址 关键字struct的使用和概念定义结构体是需要用到的关键字 结构体是值类型，在堆栈上分配地址（据网上所说堆栈就是栈，只是换了个抽象的名字，没具体了解） 抽象类和抽象方法抽象方法：只包含了方法定义，但没有具体实现的方法，需要其子类或者子类的子类来具体实现。 抽象类：含有一个或多个抽象方法的类称为抽象类。抽象类不能被实例化，这是因为它包含了没有具体实现的方法。 使用abstract关键字来定义抽象类和方法，使用格式如下 1234567public abstract class SB //定义了抽象类SB&#123;public abstract void DSB(); //定义了抽象方法DSB&#125; 子类继承抽象父类后，可以使用override关键字覆盖父类中的抽象方法，并做具体的实现，格式如下： 。。。。没有格式，把上面的abstract换成override就ojbk了 接口和类就是定义一组数据结构，通过这组数据结构可以调用组件对象的功能。反正和抽象类差不多，可以看成是类的模板 接口的特点、定义和使用定义格式： 12345678public interface SB//关键字interface&#123;Int DSB();//接口已规定是public，声明时不需要访问级别修饰&#125; 子类可以继承多个接口，实现接口中的方法不需要使用关键字“override” 接口也可以实现多态，这和抽象类一样，书上一句很无语的话。。。 使用的时候就是子类继承啦。。。 抽象类和接口的区别? 抽象类除了拥有抽象成员以外，还可以拥有非抽象成员；而接口所有成员都是抽象的； 抽象成员可以是私有的，而接口一般都是公开的（不太清楚这里的“一般”，那么“不一般”又是什么呢？）； 接口中不能含有构造函数、析构函数、静态成员、和常量； C#只支持单继承，一个子类只能继承一个父类。而一个子类却能继承多个接口 Using 关键字两种用法一种是引用命名空间，另一种是。。。老师课堂上的忘了，但网上查了，如下： 定义一个范围，在范围结束时处理对象。 场景： 当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要离开了这个代码段就自动调用这个类实例的Dispose。 要达到这样的目的，用try…catch来捕捉异常也是可以的，但用using也很方便。 1234567using (Class1 cls1 = new Class1(), cls2 = new Class1())&#123; // the code using cls1, cls2&#125; // call the Dispose on cls1 and cls2 网上说还有一种功能给命名空间起个“外号”。。。 关键字new&emsp;&emsp;C#不允许在安全代码中使用指针，因此要处理对中的数据就需要使用引用类型，使用new关键字实例化引用数据类型的对象，并指向堆中的对象数据。 内置的引用类型有两种分别是System.Object和System.String &emsp;&emsp;C#中数组也被看作一个带有方法和属性的对象，所以定义数组时，也需要用到new 多态的特性及意义！多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。 对不同类的对象发出相同的消息将会有不同的行为，就是同一个处理手段可以用来处理多种不同的情况 没有继承就没有多态！ 提高了代码的维护性(继承保证) 提高了代码的扩展性(由多态保证) 全是网上查的，这算是特性和意义吧。。。 Namespace关键字&emsp;&emsp;简单的说就是定义命名空间用的关键字，往复杂了说呢，说了也不懂，跳过 流流是.NET操作文件的基本类。对文件的输入输出操作都要用到流。流分为输入流和输出流。 懒得写了，课本165页。。。 书本重点例题：p32 p82p83 p89-91 p97 p99 p117 p113（改写后的代码） p175","categories":[{"name":"C#","slug":"C","permalink":"https://codesong.work/categories/C/"}],"tags":[{"name":"复习","slug":"复习","permalink":"https://codesong.work/tags/复习/"}]}]}
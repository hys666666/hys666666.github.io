{"meta":{"title":"CodeSong By Blog","subtitle":"Welcome to my world!","description":"火把倒下，火焰依然向上","author":"CodeSong","url":"https://codesong.work","root":"/"},"pages":[{"title":"分类","date":"2019-08-16T01:57:38.000Z","updated":"2020-03-28T06:23:37.000Z","comments":false,"path":"categories/index.html","permalink":"https://codesong.work/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-16T02:25:50.000Z","updated":"2020-03-28T06:23:56.000Z","comments":false,"path":"about/index.html","permalink":"https://codesong.work/about/index.html","excerpt":"","text":"生命在于折腾，博客终于耍起来啦！开森！ 可以做少一点，但是不能什么都不做 本博客由 Hexo 强力驱动，主题：NexT.Pisces v5.1.4 本博客于2019年8月搭建"},{"title":"我的简历","date":"2020-09-21T13:23:40.000Z","updated":"2020-09-21T13:54:56.808Z","comments":false,"path":"resume/index.html","permalink":"https://codesong.work/resume/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-16T01:58:57.000Z","updated":"2020-03-28T06:21:51.000Z","comments":false,"path":"tags/index.html","permalink":"https://codesong.work/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MYSQL的MVCC原理","slug":"MYSQL的MVCC原理","date":"2020-09-25T07:10:11.000Z","updated":"2020-09-27T01:44:52.566Z","comments":true,"path":"posts/e6aff96f.html","link":"","permalink":"https://codesong.work/posts/e6aff96f.html","excerpt":"","text":"MYSQL的MVCC原理 CSDN的文章 数据库脏读、事务的四大特性、四大隔离级别、三大范式CSDN的文章","categories":[{"name":"引用外链文章","slug":"引用外链文章","permalink":"https://codesong.work/categories/引用外链文章/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://codesong.work/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codesong.work/tags/数据库/"},{"name":"MVCC","slug":"MVCC","permalink":"https://codesong.work/tags/MVCC/"},{"name":"脏读","slug":"脏读","permalink":"https://codesong.work/tags/脏读/"},{"name":"事务","slug":"事务","permalink":"https://codesong.work/tags/事务/"},{"name":"范式","slug":"范式","permalink":"https://codesong.work/tags/范式/"}]},{"title":"MYSQL连环13问","slug":"MYSQL连环13问","date":"2020-09-25T06:57:11.000Z","updated":"2020-09-25T07:00:38.331Z","comments":true,"path":"posts/7d35c1a.html","link":"","permalink":"https://codesong.work/posts/7d35c1a.html","excerpt":"","text":"MYSQL连环13问 蓝桥的文章","categories":[{"name":"引用外链文章","slug":"引用外链文章","permalink":"https://codesong.work/categories/引用外链文章/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://codesong.work/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codesong.work/tags/数据库/"},{"name":"索引","slug":"索引","permalink":"https://codesong.work/tags/索引/"}]},{"title":"Java中new一个对象的创建过程","slug":"Java中new一个对象的创建过程","date":"2020-09-25T03:00:09.000Z","updated":"2020-09-25T03:48:01.806Z","comments":true,"path":"posts/def49b5c.html","link":"","permalink":"https://codesong.work/posts/def49b5c.html","excerpt":"","text":"new一个Java对象在Java程序的运行过程中每时每刻都有对象在生生死死，这篇文章将会简单讨论对象的创建过程（指普通的Java对象，不包括数组和Class等对象） 当虚拟机遇到一条new指令时 首先会查看对象对应的类是否被加载到内存中，如果没有则需要进行相应的类加载过程（加载、解析、初始化等）。 在类的加载检查通过之后，虚拟机将会为新生对象分配内存（从堆中划分一块对象所需的内存）根据使用的垃圾收集器不同，使用不同的分配机制： 指针碰撞：当虚拟机使用复制算法或标记整理算法实现的垃圾收集器时，内存区域是规整的，已经被使用的内存放在一边，空闲的在另一边，中间使用一个指针作为分界点的指示器（用来标识两者的分界）。分配内存时，就是将指针向空闲的内存那一边移动一段相应对象需要的内存大小距离。（移动一个对象大小） 空闲列表：当虚拟机使用标记清除算法实现的垃圾收集器时，内存区域并不是规整的。可能是已使用的和未被使用的空间相互交错，所以虚拟机需要维护一个列表，上面记录了那些内存是可用的，从中划分一个足够大的内存分配给对象实例，并且更新列表上的记录。 实例对象的内存空间分配完成后，虚拟机有可能会对内存空间进行初始化，初始化为零值（不包括对象头）。由策略的不同，这一工作有可能在内存分配之前就已经完成。 接下来就是设置对象头信息，比如：所属类、类的元数据，对象的哈希码，GC分代年龄等。 执行new指令之后 调用对象的实例构造器（init方法），对实例的属性进行设置，按照程序员的意愿进行初始化，这样一个真正可用的对象就诞生啦！","categories":[{"name":"Java","slug":"Java","permalink":"https://codesong.work/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codesong.work/tags/Java/"},{"name":"内存","slug":"内存","permalink":"https://codesong.work/tags/内存/"},{"name":"JVM","slug":"JVM","permalink":"https://codesong.work/tags/JVM/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://codesong.work/tags/虚拟机/"}]},{"title":"Mybatis的mapper.xml（映射）传入参数方式","slug":"Mybatis的mapper-xml（映射）传入参数方式","date":"2020-09-23T12:02:11.000Z","updated":"2020-09-25T06:59:59.449Z","comments":true,"path":"posts/b705a9cd.html","link":"","permalink":"https://codesong.work/posts/b705a9cd.html","excerpt":"","text":"Mybatis的mapper.xml（映射）传入参数方式 CSDN的文章","categories":[{"name":"引用外链文章","slug":"引用外链文章","permalink":"https://codesong.work/categories/引用外链文章/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://codesong.work/tags/Mybatis/"},{"name":"映射","slug":"映射","permalink":"https://codesong.work/tags/映射/"}]},{"title":"事务是什么？","slug":"事务是什么？","date":"2020-09-23T07:38:37.000Z","updated":"2020-09-23T07:50:49.128Z","comments":true,"path":"posts/f8718450.html","link":"","permalink":"https://codesong.work/posts/f8718450.html","excerpt":"","text":"在数据库中,所谓事务是指一组逻辑操作单元,有多个添加，多个修改，多个删除，连接到一起一次执行，要么成功要么失败 事务的操作:先定义开始一个事务,然后对数据作修改操作,这时如果提交(COMMIT),这些修改就永久地保存下来,如果回退(ROLLBACK),数据库管理系统将放弃所作的所有修改而回到开始事务时的状态 事务的ACID(acid)属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态,主键约束与外键约束。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响 JDBC的事务处理事务处理：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。 当在一个事务中执行多个操作时， 要么所有的事务都被提交(commit) 要么整个事务回滚(rollback)到最初状态 当一个连接对象被创建时，默认情况下是自动提交事务： 每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚 为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭, 则需要恢复其自动提交状态","categories":[{"name":"数据库","slug":"数据库","permalink":"https://codesong.work/categories/数据库/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://codesong.work/tags/事务/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codesong.work/tags/JDBC/"}]},{"title":"Struts2与Struts1的区别","slug":"Struts2与Struts1的区别","date":"2020-06-26T12:08:22.000Z","updated":"2020-06-26T12:25:49.094Z","comments":true,"path":"posts/422fe07c.html","link":"","permalink":"https://codesong.work/posts/422fe07c.html","excerpt":"","text":"Struts 2框架Struts2并没有继承Struts1的特点，反而和WebWork非常类似。因为Struts2是在WebWork的基础上发展出来的，它在各种功能和性能方面都有很好的保证，吸收了Struts1和WebWork的优势，所以它也是一个非常优秀的框架 Struts 2 和Struts 1的不同点：Action类的编写 Struts 1中，Action一般继承基类org.apache.struts.action.Action Struts 2 中，Action类可以实现一个Action接口，也可以实现其他接口，也可以继承ActionSupport基类，甚至不用实现任何接口，只编写execute函数即可！ Action的运行模式 Struts 1 中，Action是单态的，系统实例化一个对象来处理多个请求，为每个请求分配一个线程，在该线程中运行execute函数。因此在开发中需要特别小心，Action资源必须是线程安全的或同步的。 Struts 2中，Action为每个请求产生一个实例，不会产生线程安全问题，并且系统能及时回收资源垃圾，不会有废弃空间的问题。 对Wbe容器的依赖 Struts 1 中，Action的execute函数，传入了Servlet API：HttpServletRequest 和 HttpServletresponse，使得测试必须依赖于Web容器。 Struts 2 中，可以不传入这两个参数，可以通过其它方式访问它们。因此，Action不依赖于容器，允许Action脱离容器单独被测试对表单数据的封装 Struts 1 中，使用ActionForm来封装表单数据，所有的ActionForm必须继承org.apache.struts.action.ActionForm，有可能造成ActionForm类和VO类重复编码。 Struts 2 中，直接在Action中编写表单数据相对应的属性，可以不用编写ActionForm，并且这些属性可以通过Web页面上的标签访问。 Struts 2 工作规则常用的组件 FilterDispatcher过滤器 JSP Action JavaBean 配置文件等 工作规则对于一个动作，执行步骤如下： 1.用户输入，JSP表单的请求被FilterDispatcher截获。 2.FilterDispatcher将表单信息转交给Action，并封装在Action内。 3.Action调用JavaBean（DAO）。 4.Action返回要跳转到的JSP页面逻辑名称给框架。 5.框架根据逻辑名称找到相应的网页地址，进行跳转，结果在JSP上显示。 基本配置Myeclipse导入Struts 2之后需要配置WEB-INF/web.xml文件。1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" id=\"WebApp_ID\" version=\"3.1\"&gt; &lt;display-name&gt;XiTi12&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 表示使用org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter过滤器来拦截求，并起名为struts2，过滤目标为项目下的所有资源。 Struts 2 中的配置文佳一般为struts.xml，放到WEB-INF/classes目录中，编写时放在项目的src根目录下。下面是在struts.xml中配置Action以及相关虚拟页面名称：12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.1//EN\" \"http://struts.apache.org/dtds/struts-2.1.dtd\"&gt;&lt;struts&gt; &lt;package name=\"struts2\" extends=\"struts-default\"&gt; &lt;action name=\"query\" class=\"prj12.QueryAction\"&gt; &lt;result name=\"success\"&gt;/show.jsp&lt;/result&gt; &lt;result name=\"fail\"&gt;/query.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; extends属性表示继承一个默认的配置文件struts-default，一般都继承它。&lt;action&gt;中的那么属性表示Action被提交是的路径，class指定动作类的路径，在jsp中表单要提交的路径：“/prj12/query.action”，这是WebWork风格，“.action”是默认情况下规定的。&lt;result&gt;表示的就是虚拟名称和实际页面的映射。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://codesong.work/categories/JavaEE/"}],"tags":[{"name":"Struts","slug":"Struts","permalink":"https://codesong.work/tags/Struts/"},{"name":"Struts2","slug":"Struts2","permalink":"https://codesong.work/tags/Struts2/"}]},{"title":"Struts2相关","slug":"Struts2相关","date":"2020-06-26T12:00:09.000Z","updated":"2020-06-26T12:25:49.097Z","comments":true,"path":"posts/54de75b4.html","link":"","permalink":"https://codesong.work/posts/54de75b4.html","excerpt":"","text":"#在Action中访问Web对象request、response、application、session对象获取：123456789101112131415import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionContext;...public String execute() throws Exception&#123; //获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //获取reponse对象 HttpServletResponse response = ServletActionContext.getResponse(); //获取application对象 ServletContext application = ServletActionContext.getServletContext(); //获取Session对象 Map session = ActionContext.getContext().getSession();&#125;... 这里的Session是个Map对象。在Struts2中，底层的Session被封装成了Map类型，可以直接操作这个map进行对session的写入和读取操作，而不是直接去操作HttpSession（）","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://codesong.work/categories/JavaEE/"}],"tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://codesong.work/tags/Struts2/"}]},{"title":"Hibernate的动态实体模型","slug":"Hibernate的动态实体模型","date":"2020-06-22T14:53:53.000Z","updated":"2020-06-22T15:02:39.810Z","comments":true,"path":"posts/a72cd1a3.html","link":"","permalink":"https://codesong.work/posts/a72cd1a3.html","excerpt":"","text":"在Hibernate中对数据库进行操作，有一种方法可以不用定义JavaBean(PO)。就是利用 动态实体模型 Session对对象进行操作的函数有两个版本，分别是对JavaBean操作和对动态实体模型进行操作 映射文件修改在动态实体模型中，由于不存在PO，映射文件需要进行相应的修改，例：1&lt;class name=\"po.Book\" table=\"T_BOOK\"&gt; 改为： 1&lt;class entity-name=\"Book_entity\" table=\"T_BOOK\"&gt; 并在各个属性的映射命令内指定数据类型，修改后内容如下： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\" &gt;&lt;hibernate-mapping&gt; &lt;class entity-name=\"Book_entity\" table=\"T_BOOK\"&gt; &lt;id name=\"bookId\" column=\"BOOKID\" type=\"java.lang.Integer\"&gt; &lt;generator class=\"assigned\" /&gt;&lt;!--主键的生成策略，assigned表示由用户赋值--&gt; &lt;/id&gt; &lt;property name=\"bookName\" column=\"BOOKNAME\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;property name=\"bookPrice\" column=\"BOOKPRICE\" type=\"java.lang.Double\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 对动态实体模型操作的函数内内传入的第一个参数为Book_entity（entity-name） 是动态实体模型的实体名，第二个为主键值。并且，在Hibernate中，动态实体用HashMap来表达：key表示动态实体内的属性名称，value表示值 1234...HashMap hm = (HashMap)session.get(\"Book_entity\",1);hm.get(\"bookName\");//将返回查询到的实体的bookName属性值，通过key来访问value...","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://codesong.work/categories/JavaEE/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://codesong.work/tags/Hibernate/"},{"name":"动态实体模型","slug":"动态实体模型","permalink":"https://codesong.work/tags/动态实体模型/"}]},{"title":"Hibernate框架","slug":"Hibernate框架","date":"2020-06-22T14:34:42.000Z","updated":"2020-06-22T14:55:01.623Z","comments":true,"path":"posts/d85fbc26.html","link":"","permalink":"https://codesong.work/posts/d85fbc26.html","excerpt":"","text":"Hibernate框架Hibernate是Java中对象和关系的映射的解决方案，将数据库中的一条记录看成一个Java对象，大大方便了编程，提高了可维护性 ORMapping（对象关系映射） 是软件开发过程中数据库层比较流行的设计思想。Hibernate就是为了规范ORMapping开发而发布的一个框架。 类似的还有iBATIS、EntityBean等。 &emsp;&emsp;在某些大型应用场合，对数据库中的记录进行操作，Inset，Delete，Update，Select等。为了符合MVC模式，可以在DAO里面实现，但也由此引出一个问题，DAO开发人员必须懂得数据库的复杂操作，如果数据库改变时DAO的代码必须改变，如： 当数据库的表有所改动时，DAO里的代码也要改动，这样带来了很大不便。 很多时候SQL语句的结构基本不变，变化的只是表名，列名等。所以Hibernate将表名和列名进行封装，使DAO的开发人员看起来像是对对象进行操作。 &emsp;&emsp;在JavaBean中封装了数据库中的持久化信息，因此称为 PO（Persistence Object） 。在ORMapping中，一个PO对象一般表示数据表中的一条记录，只是对这个记录的操作可以简化成对这个Bean对象的操作，操作之后数据库中的记录相应变化，Hibernate框架中提供了一些能够对这些对象进行操作的函数。 常用组件：* PO（Persistence Object） * 框架API * Hibernate配置文件 * Hibernate映射文件等 Hibernate框架的工作规则：对一个数据库进行操作，执行步骤如下： 1.框架API通过读取Hibernate配置文件，连接数据库 2.当对PO进行操作时，框架API通过Hibernate映射文件，来决定决定操作的表明和列名 3.框架API执行SQL语句 所以需要提前完成以下几个步骤： 1.编写Hibernate配置文件，里面有连接到数据库需要的信息 2.编写对应记录的类（PO） 3.编写Hibernate映射文件，将PO和表映射，PO中的属性和表中的列映射 4.编写DAO，使用Hibernate进行数据库操作 Hibernate配置文件hibernate.cfg.xml默认在src目录下，该文件主要是为了连接到数据库12345678910111213141516171819202122&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;!-- Generated by MyEclipse Hibernate Tools. --&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.url\"&gt; jdbc:mysql://localhost:3306/javabean &lt;/property&gt; &lt;property name=\"dialect\"&gt; org.hibernate.dialect.MySQLDialect&lt;!--连接的是MySQL数据库 --&gt; &lt;/property&gt; &lt;property name=\"connection.password\"&gt;root&lt;/property&gt; &lt;property name=\"connection.driver_class\"&gt; com.mysql.jdbc.Driver &lt;!--MySQL数据库连接驱动版本5 --&gt; &lt;/property&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 编写PO 根据JavaBean规范编写即可 编写后这个类目前是无法被系统识别的，因为不清楚和数据库表的关系。因此需要编写一个 配置文件 PO配置文件 一般和PO放在同一个包下，通常命名为 po名+“.hbm.xml” ,例如 Book.hbm.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\" &gt;&lt;hibernate-mapping&gt; &lt;class name=\"po.Book\" table=\"T_BOOK\"&gt; &lt;id name=\"bookId\" column=\"BOOKID\"&gt; &lt;generator class=\"assigned\" /&gt;&lt;!--主键的生成策略，assigned表示由用户赋值--&gt; &lt;/id&gt; &lt;property name=\"bookName\" column=\"BOOKNAME\"&gt;&lt;/property&gt; &lt;property name=\"bookPrice\" column=\"BOOKPRICE\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 这就是配置文件的内容模板了，可以有多个，多个表多个类的映射。还需要将此文件在hibernate.cfg.xml文件中注册，使得系统能正确识别文件： 12345678&lt;hibernate-configuration&gt;&lt;session-factory&gt; ... ... ... &lt;mapping resource=\"po/Book.hbn.xml\" /&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt;","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://codesong.work/categories/JavaEE/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://codesong.work/tags/Hibernate/"}]},{"title":"利用Hibernate进行简单数据库操作","slug":"利用Hibernate进行简单数据库操作","date":"2020-06-22T12:54:10.000Z","updated":"2020-06-22T13:52:26.007Z","comments":true,"path":"posts/246b5d28.html","link":"","permalink":"https://codesong.work/posts/246b5d28.html","excerpt":"","text":"Session代表与数据库之间的一次操作，获取Session之后就可以使用Session对数据库进行操作，工作完成后需要关闭：1session.close() Session获取方式一： 读取Hibernate配置文件，使用org.hibernate.cfg.configuration类读取配置文件。 使用方法： configure()，读取默认的hibernate.cfg.xml文件 1Configuration conf = new Configuration().configure(); Hibernate中，数据库操作是用 org.hibernate.Session 完成的， Session 由 org.hibernate.SessionFactory 管理，生成 SessionFactory 代码： 1SessionFactory sf = conf.buildSessionFactory(); 利用 SessionFactory 打开Session： 1Session session = sf.openSession(); Session获取方式二：在Myeclipse中也提供了一个专门负责进行Session生成的类 创建一个util包，包下创建一个文件，右键后选择Other… 在弹出的页面选择 Hibernate—&gt;Hibernate Session Factory 该类有两个静态方法，getSession和closeSession，用来生成和关闭Session，它用到了很多优化的机制，比较高效。 打开Session：1Session session = util.HibernateSessionFactory.getSession(); 关闭Session：1util.HibernateSessionFactory.closeSession(); 对数据库增删改查注意： Session的事务不是自动提交的，如果需要对数据库进行增、删、改操作，默认情况下需要开启一个事务（org.hibernate.Transaction），如下：123Transaction tran = session.beginTransaction();...//数据库改动tran.commit(); 添加操作 利用Session将数据保存到数据库中： 1Session.save(Object);//如果存在主键冲突则抛出异常 保存或者覆盖： 1Session.saveOrUpdate(Object);//如果主键存在则修改记录，否则保存 查询操作最简单的查询： 根据主键查询一条记录 Object Session.get(PO对应的类，主键)1Book book = (Book)session.get(Book.class,\"001\"); 不存在则返回null 修改操作利用Session将修改后的数据写入数据库：1234567Sesson.update(Object);``` 或者```javaSession.saveOrUpdate(Object); 如果主键存在则修改记录，否则保存 删除操作利用Session删除记录： 1Session.delete(Object);","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://codesong.work/categories/JavaEE/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://codesong.work/tags/Hibernate/"}]},{"title":"Struts框架","slug":"Struts框架","date":"2020-06-22T07:55:45.000Z","updated":"2020-06-22T13:52:51.060Z","comments":true,"path":"posts/e61e5360.html","link":"","permalink":"https://codesong.work/posts/e61e5360.html","excerpt":"","text":"Struts框架为了规范MVC开发而发布的一个框架，类似的还有WebWork，SpringMVC等 常用的组件有： JSP ActionServlet ActionForm Action JavaBean 配置文件 Struts工作规则:1.用户输入，JSP表单提交给ActionServlet 2.ActionServlet将表单封装到ActionForm内，转交给Action 3.ActionServlet并不直接处理业务逻辑，而是让Action来调用JavaBean（DAO） 4.Action返回要跳转的JSP页面地址给ActionServlet 5.ActionServlet进行跳转，结果在JSP上显示 ActionServletActionServlet无需自己实现，在web.xml文件内的配置（Myeclipse）中可自动生成123456789101112131415161718192021&lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;3&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;detail&lt;/param-name&gt; &lt;param-value&gt;3&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ActionForm ActionForm必须继承org.apache.struts.action.ActionForm 必须在struts-config.xml中进行注册:123456&lt;form-beans&gt; &lt;form-bean name=\"loginForm\" type=\"LoginAction.LoginForm\"&gt; &lt;/form-bean&gt;&lt;/form-beans&gt; Action Action必须继承org.apache.struts.action.Action 必须重写execute方法，该方法处理业务逻辑，ActionServlet会自动调用该方法，返回要跳转的JSP页面地址。在底层通过反射机制进行 1public ActionForward execute(ActionMapping mapping, LoginForm form, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;&#125; 必须在struts-config.xml中进行注册:1234567&lt;action-mappings&gt; &lt;action path=\"/login\" name=\"loginForm\" type=\"com.yourcompany.struts.action.LoginAction\"&gt; &lt;/action&gt;&lt;/action-mappings&gt;","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://codesong.work/categories/JavaEE/"}],"tags":[{"name":"struts","slug":"struts","permalink":"https://codesong.work/tags/struts/"}]},{"title":"MVC模式","slug":"MVC模式","date":"2020-06-19T09:10:48.000Z","updated":"2020-06-22T13:13:41.145Z","comments":true,"path":"posts/c0bd5abd.html","link":"","permalink":"https://codesong.work/posts/c0bd5abd.html","excerpt":"","text":"MVC设计模式（设计思想）软件开发过程中比较流行的设计思想M（Model模型）:封装应用程序的数据结构和事物逻辑，为视图服务 JavaBean（DAO） V（View视图）:模型的外在表现，模型状态改变时，有所体现 JSP C（Controller控制器）:对用户的输入进行响应，将模型和视图联系到一起，负责将数据写到模型中，并调用视图 Servlet &nbsp;&nbsp;将程序分成了不同的三个模块，显示，业务逻辑，过程控制都各自独立，软件可伸缩性和可维护性都有了很大的优势。 步骤如下： 1.Servlet（Controller）接收参数，封装到JavaBean（Model） 2.调用Javabean（Model）的方法查询数据库，结果暂存在JavaBean（Model） 3.Servlet（Controller）跳转到JSP（View），就是JSP（View）使用JavaBean（model），得到结果并且显示","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://codesong.work/categories/设计模式/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://codesong.work/tags/MVC/"},{"name":"JavaEE","slug":"JavaEE","permalink":"https://codesong.work/tags/JavaEE/"}]},{"title":"蓝桥2013真题C++B组（三）","slug":"蓝桥2013真题C-B组（三）","date":"2020-04-22T10:31:43.000Z","updated":"2020-04-22T11:01:45.000Z","comments":true,"path":"posts/c73a0382.html","link":"","permalink":"https://codesong.work/posts/c73a0382.html","excerpt":"","text":"第39级台阶&emsp;&emsp;小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级! 站在台阶前，他突然又想着一个问题：&emsp;&emsp;如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？ 很明显是类似斐波那契数的东西f(n){return f(n-1)+f(n-2);}，可以用递归来做，模拟迈步子，当把所有台阶都上完时（每一步都可以迈一个台阶或者两个台阶），再判断是否是偶数步数即可，以下为代码部分：12345678910111213141516171819#include &lt;cstdio&gt;/***************************** * My Blog: CodeSong.work * ***************************** */int ans=0;void f(int n,int step)&#123;//n为剩余台阶数，step为已走步数 if(n&lt;0) return ; if(n==0&amp;&amp;step%2==0) ans++; f(n-1,step+1); f(n-2,step+1);&#125;int main()&#123; f(39,0);//初始总共有39级台阶，已走的步数为零 printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"蓝桥杯真题","slug":"蓝桥杯真题","permalink":"https://codesong.work/categories/蓝桥杯真题/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://codesong.work/tags/蓝桥杯/"},{"name":"算法","slug":"算法","permalink":"https://codesong.work/tags/算法/"},{"name":"C/C++","slug":"C-C","permalink":"https://codesong.work/tags/C-C/"}]},{"title":"蓝桥2013真题C++B组（二）","slug":"蓝桥2013真题C-B组（二）","date":"2020-04-22T10:31:36.000Z","updated":"2020-04-22T11:04:33.000Z","comments":true,"path":"posts/8a24a0d0.html","link":"","permalink":"https://codesong.work/posts/8a24a0d0.html","excerpt":"","text":"马虎的算式小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。有一次，老师出的题目是：36 x 495 = ?他却给抄成了：396 x 45 = ?但结果却很戏剧性，他的答案竟然是对的！！因为 36 * 495 = 396 * 45 = 17820类似这样的巧合情况可能还有很多，比如：27 * 594 = 297 * 5假设 a b c d e 代表1~9不同的5个数字（注意是各不相同的数字，且不含0）能满足形如： ab * cde = adb * ce 这样的算式一共有多少种呢？请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。答案直接通过浏览器提交。注意：只提交一个表示最终统计种类数的数字，不要提交解答过程或其它多余的内容。能满足形如：ab * cde = adb * ce这样的算式一共有多少种？ 既然左右替换算是一种，直接枚举出所有数的组合，然后判断计算结果是否相等即可，非常简单，以下为代码部分： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;/***************************** * My Blog: CodeSong.work * ***************************** */int main()&#123; int ans = 0;//记录答案 for(int a=1;a&lt;10;++a)&#123; for (int b = 1; b &lt; 10; b++) &#123; if(b==a) continue; for (int c = 1; c &lt; 10; c++) &#123; if(c==a||c==b) continue; for (int d = 1; d &lt; 10; d++) &#123; if(d==a||d==b||d==c) continue; for (int e = 1; e &lt; 10; e++) &#123; if(e==a||e==b||e==c||e==d) continue; //ab * cde = adb * ce int t1 = (a*10 + b)*(c*100+d*10+e); int t2 = (a*100+d*10+b)*(c*10+e); if(t1==t2) ans++; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"蓝桥杯真题","slug":"蓝桥杯真题","permalink":"https://codesong.work/categories/蓝桥杯真题/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://codesong.work/tags/蓝桥杯/"},{"name":"算法","slug":"算法","permalink":"https://codesong.work/tags/算法/"},{"name":"C/C++","slug":"C-C","permalink":"https://codesong.work/tags/C-C/"}]},{"title":"蓝桥2013真题C++B组（一）","slug":"蓝桥2013真题C-B组（一）","date":"2020-04-22T10:31:26.000Z","updated":"2020-04-22T10:39:53.000Z","comments":true,"path":"posts/ba324c08.html","link":"","permalink":"https://codesong.work/posts/ba324c08.html","excerpt":"","text":"高斯日记&emsp;&emsp;大数学家高斯有个好习惯：无论如何都要记日记。他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210。后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。&emsp;&emsp;这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？&emsp;&emsp;高斯出生于：1777年4月30日。在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。&emsp;&emsp;高斯获得博士学位的那天日记上标着：8113。请你算出高斯获得博士学位的年月日。提交答案的格式是: yyyy-mm-dd, 例如: 1980-03-21 这道题非常简单，由于只提交一个日期，那直接利用程序从出生那天开始跑一遍要求的次数就能够得到答案了。有两点：一、需要检查高斯出生的当天算不算是一天，可以拿题目中的例子来测试你的算法（这一步必须检查不然错了冤死了）二、由于日期有一些规定，所以需要特别处理：闰年，平年，大月，小月，月末，年末； 关于闰年，定制闰年规则不是随意设置的。 首先我们要知道，年的概念，是地球围绕太阳一周的时间（所谓公转周期）称为一年，这个周期是相当稳定的，很长时间也不会变动1秒，但是很遗憾zhidao的是这个周期并不能被一天的时间整除，真正的一年其实是365.2423天（目前）。 所以，如果每年定义为365天的话，1年就会多出0.2423天，4年就会多出0.9692天，非常接近1天，这样闰年就出现了，也就是每4年要有1年设置为366天，来抵消这多出的1天。规则为：(1)如果年份能被4整除，则该年计为闰年 可是，假如不做调整的话，当400年的时候，累计才多出96.92天，闰年的设置却多出来100天，所权以要在400年内，再撤销3个闰年。怎么撤销呢？就有了下面这个规则：(2)如果年份能被100整除，则不计为闰年 问题又来了，400年里有4个，又少了一个，所以再加一个规则就是：(3)如果年份能被400整除，则计为闰年 这样每400年里设置了97个闰年，误差被调整到400年仅有0.08天，而设置规则也并不是很麻烦，所以一直沿用了下来。* 特别注意本题难点仅在逻辑判断,以下为代码部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;/***************************** * My Blog: CodeSong.work * ***************************** */bool isLeapYear(int n)&#123; //返回是否是闰年的判断 return ((n % 4 == 0 &amp;&amp; n % 100 != 0) || n % 400 == 0);&#125;int main()&#123; int year = 1777;//年 int month = 4;//月 int day = 30;//日 int dSum = 8113;//天数 //月份的逻辑判断为容易出错的地方,还有日期的改变 while (--dSum) &#123;//先判断是否为月底 if (month == 12 &amp;&amp; day == 31) &#123; //判断是否是一年中最后的一天，year加1，month和day重置为1 year += 1; month = 1; day = 1; continue; &#125; if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10) &amp;&amp; day == 31) &#123; //判断是否是大月中的最后一天 month += 1; day = 1; continue; &#125; if ((month == 4 || month == 6 || month == 9 || month == 11) &amp;&amp; day == 30) &#123; //判断是否是小月中的最后一天 month += 1; day = 1; continue; &#125; if (month == 2 &amp;&amp; isLeapYear(year) &amp;&amp; day == 29) &#123; //单独处理闰年的月底 month += 1; day = 1; continue; &#125; if (month == 2 &amp;&amp; !isLeapYear(year) &amp;&amp; day==28) &#123; //单独处理平年的月底 month += 1; day = 1; continue; &#125; day++;//非月底则day直接增加一 &#125; printf(\"%d-%d-%d\\n\", year, month, day); return 0;&#125;","categories":[{"name":"蓝桥杯真题","slug":"蓝桥杯真题","permalink":"https://codesong.work/categories/蓝桥杯真题/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://codesong.work/tags/蓝桥杯/"},{"name":"算法","slug":"算法","permalink":"https://codesong.work/tags/算法/"},{"name":"C/C++","slug":"C-C","permalink":"https://codesong.work/tags/C-C/"}]},{"title":"个人博客部署免费的https安全证书","slug":"个人博客部署免费的https安全证书","date":"2020-03-26T12:59:04.000Z","updated":"2020-04-22T10:58:37.000Z","comments":true,"path":"posts/ce68fd7a.html","link":"","permalink":"https://codesong.work/posts/ce68fd7a.html","excerpt":"","text":"个人博客怎么部署免费的https安全证书？&emsp;&emsp;首先需要去阿里云申请一个免费的安全证书 我是一个超链接 选择免费的证书： 免费购买后，在证书控制台申请证书：后面接着提交信息，验证，几分钟就会成功了不再阐述 将证书部署到服务器上服务器系统：Ubuntu Web服务器：Apache2 前提条件 从SSL证书控制台下载相应版本的证书 服务器已安装Open SLL（反正我的是默认有了的） 操作步骤在Apache2目录下创建个目录并且将证书文件复制进去mkdir /ect/apache2/ssl cp *public.crt /etc/apache2/ssl cp *Name.key /etc/apache2/ssl 启用SSL模块sudo a2enmod ssl 修改SSL配置文件default-ssl.confvi /etc/apache2/sites-available/default-ssl.conf 参数修改如下：123456&lt;IfModules mod_ssl.c&gt;&lt;VirtualHost *:443&gt; ServerName #修改为证书绑定的域名www.YourDomainName.com。SSLCertificateFile /etc/apache2/ssl/www.YourDomainName_public.crt #将/etc/apache2/ssl/www.YourDomainName.com_public.crt替换为证书文件路径+证书文件名。SSLCertificateKeyFile /etc/ssl/apache2/www.YourDomainName.com.key #将/etc/apache2/ssl/www.YourDomainName.com.key替换为证书密钥文件路径+证书密钥文件名。SSLCertificateChainFile /etc/apache2/ssl/www.YourDomainName.com_chain.crt #将/etc/apache2/ssl/www.YourDomainName.com_chain.crt替换为证书链文件路径+证书链文件名。 sites-available：该目录存放的是可用的虚拟主机； sites-enabled：该目录存放的是已经启用的虚拟主机。 将default-ssl.conf映射至/etc/apache2/sites-enabled文件夹中建立软链接、实现二者之间的自动关联sudo ln -s /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled/001-ssl.conf 重新加载Apache2配置文件sudo /etc/init.d/apache2 force-reload 重新启动Apache2sudo /etc/init.d/apache2 restart 或者 sudo apache2ctl restart &emsp;&emsp;服务器安装https安全证书完成！","categories":[{"name":"博客","slug":"博客","permalink":"https://codesong.work/categories/博客/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"https://codesong.work/tags/ssl/"},{"name":"https","slug":"https","permalink":"https://codesong.work/tags/https/"},{"name":"安全证书","slug":"安全证书","permalink":"https://codesong.work/tags/安全证书/"}]},{"title":"Java中内存的划分-学习笔记","slug":"Java中内存的划分-学习笔记","date":"2019-08-23T10:44:04.000Z","updated":"2020-04-22T11:23:50.000Z","comments":true,"path":"posts/3a8013f5.html","link":"","permalink":"https://codesong.work/posts/3a8013f5.html","excerpt":"","text":"任何计算机程序，如果想要运行，都需要开辟一块内存空间。 &emsp;&emsp;计算机整体的内存都是由操作系统来进行管理的，所以Java程序运行需要向计算机操作系统申请一块内存。这块专属内存被划分为了五部分，这样一来每一小块内存能被更好的使用和分门别类来管理。 虚拟机栈（VM Stack）&emsp;&emsp;栈中执行每个方法的时候，方法中的局部变量都会存在这块内存中。jvm会创建一个栈帧来存储局部变量表，栈帧还存有：操作数栈，动态链接，方法出口等信息。 堆（Heap）&emsp;&emsp;堆是Java对象在内存中的存储区域，凡是用new出来的东西都在这里面。Java中的对象和数组都被分配在堆中。 堆内存里面的数据，都有默认值。规则： 数据类型 默认值 整型 0 浮点型 0.0 字符型 ‘\\u0000’ 布尔型 false 引用类型 null 方法区(Method Area) 它用于存储已被虚拟机加载的类信息，常量，静态变量，方法的信息，即时编译器编译后的代码等数据。 注意：仅仅是包含了类的相关信息 本地方法栈（Native Method Stack） 与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的本地方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 很多的算法或者一个功能的实现，都被java封装到了本地方法中，程序直接通过调用本地的方法就行了，本地方法栈就是用来存放这种方法的，实现该功能的代码可能是C也可能是C++,反正不一定就是java实现的。 Program Count Register（PC寄存器，程序计数器） 指示Java虚拟机下一条需要执行的字节码指令。 程序计数器是一块较小的内存区域，作用可以看做是当前线程执行的字节码的位置指示器。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成。 以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。 所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codesong.work/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codesong.work/tags/Java/"}]},{"title":"C#复习知识点提炼","slug":"C-复习知识点提炼","date":"2019-04-29T13:53:00.000Z","updated":"2019-08-22T12:46:00.000Z","comments":true,"path":"posts/2b58aa48.html","link":"","permalink":"https://codesong.work/posts/2b58aa48.html","excerpt":"","text":"C#知识点提炼期末复习专用 根据内部消息称，有三类题型：程序阅读题：2题简答题：2题 （主要是对概念的考查）编程题：暂定2-3题 复习要点：.net framework通用语言开发环境、.NET基础类库、.NET开发语言、visual studio.NET 集成开发环境 C#的特点 语法简介 彻底的面向对象 与Web应用紧密结合 强大的安全机制 完善的错误、异常处理机制 灵活的版本处理技术 兼容性 （老师加的）全方位的跨平台支持 ASP.NET Core 跨平台 开源 值类型和引用类型的区别值类型：该类型的数据长度固定，存放于栈内 引用类型：该类型的数据长度可变，存放于堆内 类的修饰符 abstract 抽象类，不能创建该类的实例，只能作为基类 internal 老师说，在同一程序内部访问而非指某一个命名空间内部，其它命名空间用using来使用 new 用于声明嵌套的类 private 用于声明私有嵌套类，只能在定义它的类中访问这个类 protected 用于声明保护型嵌套类，只能在定义它的类以及该类的子类中访问这个类 public 该类可以被任何其它类访问 sealed 该类不能被继承 类成员修饰符有四类 public 公有成员 Private 私有成员 Protected 保护成员 Internal 内部成员 构造函数、析构函数&emsp;&emsp;构造函数与类名相同，开头public，无返回值，主要对类的实例初始化，实例类时自动执行 &emsp;&emsp;析构函数名比析构函数多加了一个符号 ’~’，与构造函数区别在于，该函数在对象销毁时执行 继承、多态继承本质是代码重用（具体懒得写） 多态就是将子类赋值给父类，可以在父类中通过调用抽象方法来实现子类的具体功能 ASP.NET,page实例的生命周期自己找去 方法的重载与区分&emsp;&emsp;重载指的是允许存在多个同名参数，而这些函数的参数呢，是不一样的，可以是类型不一样可以是个数不一样，然后再调用这个方法时，编译器可以按照输入的参数去调用适当的方法 装箱和拆箱。重载。说简单点就是：把一个具体的子类对象赋值给了父类对象就可以理解为发生了装箱操作，将父类对象强转为具体的子类对象就是拆箱操作 里式转换法则：父类中包含的是子类对象，则可以强转成文子类对象 秀操作专用知识点 c#面向对象的思想。面向对象的思想很简单，就是对象咯（似乎是废话） 面向对象是一种模块化的、以对象为基础的设计思想，现在被广泛应用于软件设计领域。 基本单元就是对象！对象！对象！ 对象就是封装起来的代码块，功能模块？应该是的 本篇文章就是它的思想吧，太扯了跳过。。。 关键字 class 的使用和概念定义类时需要用到的关键字 类是引用类型，在堆上分配地址 关键字struct的使用和概念定义结构体是需要用到的关键字 结构体是值类型，在堆栈上分配地址（据网上所说堆栈就是栈，只是换了个抽象的名字，没具体了解） 抽象类和抽象方法抽象方法：只包含了方法定义，但没有具体实现的方法，需要其子类或者子类的子类来具体实现。 抽象类：含有一个或多个抽象方法的类称为抽象类。抽象类不能被实例化，这是因为它包含了没有具体实现的方法。 使用abstract关键字来定义抽象类和方法，使用格式如下 1234567public abstract class SB //定义了抽象类SB&#123;public abstract void DSB(); //定义了抽象方法DSB&#125; 子类继承抽象父类后，可以使用override关键字覆盖父类中的抽象方法，并做具体的实现，格式如下： 。。。。没有格式，把上面的abstract换成override就ojbk了 接口和类就是定义一组数据结构，通过这组数据结构可以调用组件对象的功能。反正和抽象类差不多，可以看成是类的模板 接口的特点、定义和使用定义格式： 12345678public interface SB//关键字interface&#123;Int DSB();//接口已规定是public，声明时不需要访问级别修饰&#125; 子类可以继承多个接口，实现接口中的方法不需要使用关键字“override” 接口也可以实现多态，这和抽象类一样，书上一句很无语的话。。。 使用的时候就是子类继承啦。。。 抽象类和接口的区别? 抽象类除了拥有抽象成员以外，还可以拥有非抽象成员；而接口所有成员都是抽象的； 抽象成员可以是私有的，而接口一般都是公开的（不太清楚这里的“一般”，那么“不一般”又是什么呢？）； 接口中不能含有构造函数、析构函数、静态成员、和常量； C#只支持单继承，一个子类只能继承一个父类。而一个子类却能继承多个接口 Using 关键字两种用法一种是引用命名空间，另一种是。。。老师课堂上的忘了，但网上查了，如下： 定义一个范围，在范围结束时处理对象。 场景： 当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要离开了这个代码段就自动调用这个类实例的Dispose。 要达到这样的目的，用try…catch来捕捉异常也是可以的，但用using也很方便。 1234567using (Class1 cls1 = new Class1(), cls2 = new Class1())&#123; // the code using cls1, cls2&#125; // call the Dispose on cls1 and cls2 网上说还有一种功能给命名空间起个“外号”。。。 关键字new&emsp;&emsp;C#不允许在安全代码中使用指针，因此要处理对中的数据就需要使用引用类型，使用new关键字实例化引用数据类型的对象，并指向堆中的对象数据。 内置的引用类型有两种分别是System.Object和System.String &emsp;&emsp;C#中数组也被看作一个带有方法和属性的对象，所以定义数组时，也需要用到new 多态的特性及意义！多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。 对不同类的对象发出相同的消息将会有不同的行为，就是同一个处理手段可以用来处理多种不同的情况 没有继承就没有多态！ 提高了代码的维护性(继承保证) 提高了代码的扩展性(由多态保证) 全是网上查的，这算是特性和意义吧。。。 Namespace关键字&emsp;&emsp;简单的说就是定义命名空间用的关键字，往复杂了说呢，说了也不懂，跳过 流流是.NET操作文件的基本类。对文件的输入输出操作都要用到流。流分为输入流和输出流。 懒得写了，课本165页。。。 书本重点例题：p32 p82p83 p89-91 p97 p99 p117 p113（改写后的代码） p175","categories":[{"name":"C#","slug":"C","permalink":"https://codesong.work/categories/C/"}],"tags":[{"name":"复习","slug":"复习","permalink":"https://codesong.work/tags/复习/"}]}]}